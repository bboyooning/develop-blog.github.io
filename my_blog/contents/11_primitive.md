---
date: '2022-06-02'
title: 'Javascript Deep Dive'
categories: ['TIL', 'Deep Dive']
summary: '11. 원시 값과 객체의 비교'
thumbnail: './deep_dive.png'
---

## 원시 값과 객체의 비교

- 자바스크립트가 제공하는 7가지 데이터 타입(number, string, boolean, null, undefined, symbol, 객체)은 크게 `원시 타입`, `객체 타입` 으로 구분할 수 있음
- 원시 타입과 객체 타입은 크게 세 가지 측면에서 다름

  1. 원시 타입의 값, 즉 원시 값은 `변경 불가능한 값(immutable value)`. <br>
     ↔️ 객체는 변경 가능한 값
  2. 원시 값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장됨. <br>
     ↔️ 객체를 변수에 할당하면 변수에는 참조 값이 저장됨.
  3. 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달됨. 이를 값에 의한 전달 이라 함.<br>
     ↔️ 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 전달됨. 이를 참조에 의한 전달 이라 함.

### 원시값

- 원시 값은 `변경 불가능한 값(immutable value)`
- 한번 생성된 원시 값은 `읽기 전용 값` 으로 변경 불가능
- 변경 불가능하다는 것은 변수가 아니라 값에 대한 진술
- 변수와 값은 구분해서 생각해야 함. <br>
  변수는 하나의 값을 저장하기 위해 확보된 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름이고, 값은 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말함.
- 즉, "원시 값은 변경 불가능하다" 는 말은 원시 값 자체를 변경할 수 없는 것이지 변수 값을 변경할 수 없다는 것은 아님.
- 변수는 언제든지 재할당을 통해 변수 값을 변경할 수 있음. 그렇기 때문에 변수라고 부름.
- 변수 ↔️ `상수` 는 재할당이 금지된 변수
- 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있지만, 단 한번만 할당이 허용되므로 변수 값을 변경할 수 없음
- 따라서 상수와 변경 불가능한 값을 동일시 하면 안됨.
- 상수는 재할당이 금지된 변수일 뿐!

<br>

- 원시 값은 어떤 일이 있어도 불변하므로, 데이터의 신뢰성을 보장함
- 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 재할당 이전의 원시 값을 변경하는 것이 아니라, 새로운 메모리 공간을 확보하고 재할당한 언시 값을 저장한 후 변수는 새롭게 재할당한 원시 값을 가리킴
- 이때 변수가 참조하던 메모리 공간의 주소가 바뀜
- 변수가 참조하던 메모리 공간의 주소가 변경된 이유는 변수에 할당된 원시 값이 변경 불가능한 값이기 때문임
- 만약 원시 값이 변경 가능한 값이었다면, 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요 없이 원시 값 자체를 변경하면 그만임! 변수가 참조하던 메모리 공간의 주소는 바뀌지 않음
- 하지만, 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없음
- 따라서 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간이 주소를 변경함.
- 값의 이러한 특성을 `불변성` 이라 함.
- 불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없음

<br>

### 문자열과 불변성

- 문자열은 다른 원시 값과 비교할 때 독특한 특징이 있음
- 0개 이상의 문자로 이뤄진 집합으로, 몇 개의 문자로 이뤄졌느냐에 따라 필요한 메모리 공간의 크기가 결정됨
- C, 자바 등과는 다르게 자바스크립트는 개발자의 편의를 위해 원시 타입인 문자열 타입을 제공함
- 이는 자바스크립트의 장점 중 하나임
- 자바스크립트의 문자열은 원시 타입이며, 변경 불가능
- 문자열이 생성된 이후에는 변경할 수가 없음을 의미함

```js
var str = 'Hello'
str = 'World'
```

- 첫번째 문이 실행되면 'Hello' 가 생성되고 식별자 str은 문자열 'Hello' 가 저장된 메모리 공간의 첫번째 메모리 셀 주소를 가리킴
- 두번째 문이 실행되면 이전에 생성된 문자열 'Hello' 를 수정하는 것이 아니라, 새로운 문자열 'World' 를 메모리에 생성하고 식별자 str 는 이것을 가리킴
- 이때, 문자열 'Hello' 와 'world' 는 모두 메모리에 존재함
- 식별자 str 은 문자열 'Hello' 를 가르키고 있다가, 문자열 'World' 를 가리키도록 변경되었을 뿐임

<br>

- 문자열의 한 문자를 변경해 보자.
- 문자열은 유사 배열 객체이면서, 이터러블 이므로 배열과 유사하게 각 문자에 접근할 수 있음

```js
var str = 'string'
str[0] = 'S'
// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있음
// 하지만 문자열은 원시 값이므로 변경할 수 없음. 이때, 에러가 발생하지 않음.

console.log(str) // string
```

- str[0]='S' 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않음
- 이처럼 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없음
- 원시 값은 어떤 일이 있어도 불변하므로 예기치 못한 변경으로서 자유로움
- 데이터 신뢰성을 보장!
- 그러나 변수에 새로운 문자열을 재할당하는 것은 가능함. 이는 기존 문자열을 변경하는 것이 아닌 새로운 문자열을 새롭게 할당하는 것이기 때문

<br>

### 값에 의한 전달

```js
var score = 80
var copy = score

console.log(score) // 80
console.log(copy) // 80

score = 100

console.log(score) // 100
console.log(copy) // 80
```

- 변수에 변수를 할당했을 때 무엇이 어떻게 전달될까?
- 이처럼 변수에 원시 값을 갖는 변수를 할당하면, 할당받는 변수(copy)에 할당되는 변수(score)의 `원시 값`이 복사되어 전달됨
- 이를 `값에 의한 전달` 이라고 함
- `score = 100` 으로 재할당 했어도, `console.log(copy)` 의 값은 `80` 이 나옴
- score 변수와 copy 변수가 숫자 값 80 갖는 다는 점에선 동일하나, 둘은 다른 메모리 공간에 저장된 별개의 값이기 때문!
- 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않음

<br>

- 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되는 것임
- 이는 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문임
- 식별자는 어떤 값을 구별해서 식별해낼 수 있는 고유한 이름으로, 값은 메모리 공간에 저장되어 있음
- 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해낼 수 있어야 하므로 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있음
- 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미
- 즉, 식별자는 메모리 주소에 붙인 이름 이라고 할 수 있음
- 이처럼 `값에 의한 전달` 도 사실은 값을 전달하는 것이 아니라, `메모리 주소` 를 전달함
- 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있음
- 중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든 <br>
  결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것

<br>

### 객체

- 객체는 프로퍼티의 개수가 정해져 있지 않으며, 동적으로 추가되고 삭제할 수 있음
- 또한 프로퍼티의 값에도 제약이 없음
- 따라서 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없음
- 자바스크립트는 클래스 없이 객체를 생성할 수 있으며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드를 추가할 수 있음
- 이는 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍 언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식임
- 따라서 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 히든 클래스 방식을 사용해 성능을 보장함

#### 변경 가능한 값

- 객체(참조) 타입의 값, 즉 객체는 `변경 가능한 값`

```js
var person = {
  name: 'Lee',
}
```

- 원시 값을 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 원사 값에 접근할 수 있음
- 즉, 원시 값을 할당한 변수는 원시 값 자체를 값으로 갖음
- 하지만 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근할 수 있음
- 참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체임
- 객체를 할당한 변수에는 생성된 객체가 실제로 저장된 메모리 공간의 주소가 저장되어 있음
- 이 값을 참조 값이라고 하는데, 변수는 이 참조 값을 통해 객체에 접근할 수 있음
  <img src="https://velog.velcdn.com/images/jhplus13/post/e02f9549-36fb-4d7b-94b7-942a7a044e7d/image.png">
- 원시 값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근함
- 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조 값을 통해 실제 객체에 접근함
- 위 예제에서 `person 변수`는 `객체 {name: 'Lee'}` 를 `가리키고(참조하고)` 있음.

<br>

- 객체는 변경 가능한 값. 따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경이 가능함
- 즉, 재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 갱신할 수도 있으며 프로퍼티 자체를 삭제할 수도 있음
- 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있고, 객체를 할당한 변수의 참조 값은 변경되지 않음

<br>

- 여러 개의 식별자가 하나의 객체를 공유할 수 있는 구조적 단점에 따른 부작용이 있음

```js
var person = {
  name: 'Lee',
}

// 참조 값을 복사(얕은 복사)
var copy = person
```

- 객체를 가리키는 변수(원본, person)를 다른 변수(사본, copy)에 할당하면 원본의 참조 값이 복사되어 전달됨
- 이를 `참조에 의한 전달` 이라 함.
  <br>

  <img src="https://velog.velcdn.com/images/jhplus13/post/cf94c86f-9ca6-4fe9-9d2b-acd797ef479f/image.png"  style="width: 748px" />

<br>

- 위 그림처럼 원본 person 을 사본 copy 에 할당하면 원본 person 의 참조 값을 복사해서 copy 에 저장함
- 이때 원본 person 과 사본 copy 는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖음
- 다시 말해, 원본 person 과 사본 copy 모두 동일한 객체를 가리킴
- 이것은 `두 개의 식별자가 하나의 객체를 공유한다`는 것임
- 따라서 원본 또는 사본 중 어느 한쪽에서 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제하면 서로 영향을 주고 받음

<br>

```js
var person = {
  name: 'Lee',
}

var copy = person

console.log(copy === person) // true

copy.name = 'Kim'
person.address = 'Seoul'

console.log(person) // { name: 'Kim', address: 'Seoul' }
console.log(copy) // { name: 'Kim', address: 'Seoul' }
```

- 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받음

<br>

- 결국 `값에 의한 전달`과 `참조에 의한 전달`은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일함
- 다만 식별자가 기억하는 메모리 공간, 즉 변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐
- 따라서 `자바스크립트`에는 참조에 의한 전달은 존재하지 않고 `값에 의한 전달`만이 존재한다고 말할 수 있음

<br>

```js
var person1 = {
  name: 'Lee',
}

var person2 = {
  name: 'Lee',
}

console.log(person1 === person2) // (1)

console.log(person1.name === person2.name) // (2)
```

- 객체 리터럴은 평가될 때마다 객체를 생성함
- person1 변수와 person2 변수가 가리키는 객체는 비록 내용은 같지만 다른 메모리에 저장된 별개의 객체임. <br>
  따라서 전혀 다른 값으로 (1)은 `false` 임
- 하지만 프로퍼티 값을 참조하는 person1.name 과 person2.name 은 값으로 평가될 수 있는 표현식으로, 모두 원시값 'Lee' 로 평가되었기 때문에 (2)는 `true` !

<br>

#### \*얕은 복사와 깊은 복사

- 객체를 프로퍼티 값으로 갖는 객체의 경우, 얕은 복사는 한 단계까지만 복사하는 것
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 말함
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체!
- 즉, 원본과 복사본은 참조 값이 다른 별개의 객체
- 하지만, 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고,
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만듦
- 참고로 원시 값을 할당한 변수를 다른 변수에
